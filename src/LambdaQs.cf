entrypoints Exp;

-- Metavariables
MVar. Var ::= Ident; -- variables
MUni. Uni ::= Ident; -- unitaries
MKey. Key ::= Ident; -- qubit symbols/unique keys

-- Types
TQref. Typ ::= "qref" "<" Key ">";          -- qubit reference
TFun.  Typ ::= "fun"  "(" Typ ";" Typ ")";  -- function
TCmd.  Typ ::= "cmd"  "(" Typ ")";          -- command
TProd. Typ ::= "prod" "(" Typ ";" Typ ")";  -- TODO: also add a variadic product type
TArr.  Typ ::= Typ "[" "]";
TUnit. Typ ::= "unit";
TBool. Typ ::= "bool";
TStr.  Typ ::= "string";
TInt.  Typ ::= "int";
TDummy. Typ ::= "dummy";

-- Expressions
EVar.  Exp ::= Var;
-- EDo.   Exp ::= "do" Exp "in" Exp; Instead, I am just using ELet for this
ELet.  Exp ::= "let" "[" Typ ";" Typ "]" "(" Exp "; " Var "." Exp ")";  -- let expression
ELam.  Exp ::= "\\"  "[" Typ ";" Typ "]" "(" Var "." Exp ")";           -- lambda abstraction
EAp.   Exp ::= "ap"  "[" Typ ";" Typ "]" "(" Exp ";" Exp ")";           -- application
ECmd.  Exp ::= "cmd" "[" Typ "]" Cmd;                                   -- encapsulation
EQloc. Exp ::= "&" Key;                                                 -- qubit locations TODO: still needed?
EProj. Exp ::= "proj" "<" Integer ">" "[" Typ ";" Typ "]" "(" Exp ")";  -- currently just 1 or 2 as these are pairs
EPair. Exp ::= "pair" "[" Typ ";" Typ "]" "(" Exp ";" Exp ")";          -- TODO: support variadic tuples
ETriv. Exp ::= "<>";                                                    -- can also call it null
ETrue. Exp ::= "true";
EFls.  Exp ::= "false";
EIte.  Exp ::= "if" "[" Typ "]" "(" Exp ";" Exp ";" Exp ")";
ENot.  Exp ::= "not" Exp;
-- TODO: make sure precedence is correct here
EEq.   Exp ::= Exp "==" Exp;
EAdd.  Exp ::= Exp "+" Exp;
EInt.  Exp ::= Integer;
-- ERef.  Exp ::= Exp "requires" Ref "ensures" Ref; -- TODO

internal EVarT. Exp ::= "(" Var ":" Typ ")";

-- Commands
CRet.   Cmd ::= "ret" "[" Typ "]" Exp;                                  -- return
CBnd.   Cmd ::= "bnd" "[" Typ ";" Typ "]" "(" Exp "; " Var "." Cmd ")"; -- sequence
CNew.   Cmd ::= "new" Var "in" Cmd;                                     -- new qubit reference
CGap.   Cmd ::= Uni "(" Exp ")";                                        -- unitary gate application
CDiag.  Cmd ::= "D" "(" Uni "," Uni ";" Exp "," Exp ")";                -- diagonal gate application
CMeas.  Cmd ::= "meas" "(" Exp ")";                                     -- measurement

{-
-- Refinements
REq.  Ref ::= Var "=" Integer;

-- Programming idioms

-- sequential composition of commands
seq. Cmd ::= "{" Var "<-" Cmd ";" Cmd "}";
define seq x m1 m2 = CBnd x (ECmd m1) m2;

-- `do e` executes an encapsulated command and returns its result
-- This encoding requires an explicit variable argument
-- Example: do 1 x
do. Exp ::= "do" Exp Var;
define do e x = ECmd (CBnd x e (CRet (EVar x)));

-- procedure
proc. Exp ::= "proc" "(" Var ":" Typ ")" Cmd;
define proc x t m = ELam x t (ECmd m);

-- procedure call
-- This encoding also requires an explicit variable argument
pcall. Exp ::= "call" Exp "(" Exp ")" Var;
define pcall e1 e2 x = ECmd (CBnd x (EAp e1 e2) (CRet (EVar x)));;
-}
